# Edge-to-Cloud Architecture Migration PRD

## Project Overview
Transform the existing local MTConnect monitoring system into a modern Edge-Cloud architecture where:
- **Edge**: Local data collection stays on-premises for security
- **Cloud**: Dashboard and analytics move to cloud for accessibility

## Current State Analysis
- ‚úÖ **Local System**: 100% complete, monitoring 8 FANUC machines
- ‚úÖ **ADAM-6050 PoC**: Proven jsmodbus can replace .NET DLL
- üîÑ **Architecture**: Currently everything runs locally

## Target Architecture

### Edge Component (Local)
- **Data Collection**: MTConnect agents + ADAM-6050 digital I/O
- **Data Processing**: Real-time machine state management
- **Data Transmission**: HTTP/HTTPS to cloud API
- **Security**: No inbound ports, only outbound connections
- **Technology**: Node.js/TypeScript (existing codebase)

### Cloud Component (Railway.app)
- **Dashboard**: Web interface accessible from anywhere
- **API**: RESTful endpoints for data ingestion and serving
- **Database**: MongoDB for machine data and TimeSeries
- **Technology**: NestJS/TypeScript/Mongoose
- **Deployment**: Docker containers on Railway

## Technical Requirements

### Edge Requirements
1. **Data Collection**
   - Maintain existing MTConnect XML parsing
   - Integrate ADAM-6050 using jsmodbus (no .NET dependency)
   - Real-time machine state tracking
   - Cycle time calculations

2. **Data Transmission**
   - HTTP/HTTPS client with retry logic
   - Batch data sending (every 30 seconds)
   - Outbox pattern for reliability
   - Compression for efficiency

3. **Security**
   - No inbound network connections
   - HTTPS only for outbound
   - API key authentication
   - Local data encryption at rest

### Cloud Requirements
1. **Data Ingestion API**
   - RESTful endpoints for receiving edge data
   - Authentication and authorization
   - Data validation and sanitization
   - Rate limiting and DDoS protection

2. **Dashboard API**
   - Real-time machine status endpoints
   - Historical data queries
   - Aggregated statistics
   - WebSocket for real-time updates

3. **Database Design**
   - Machine configurations (MongoDB collections)
   - Real-time machine states (MongoDB TimeSeries)
   - Historical data with time-series optimization
   - User management and permissions

4. **Frontend Dashboard**
   - Responsive web interface
   - Real-time machine status display
   - Historical charts and analytics
   - Mobile-friendly design

## Implementation Strategy

### Phase 1: Cloud Infrastructure
- Set up Railway.app deployment
- Create NestJS application structure
- Implement PostgreSQL database
- Basic API endpoints

### Phase 2: Edge Integration
- Modify existing local system
- Add HTTP client for cloud communication
- Implement ADAM-6050 integration
- Test data transmission

### Phase 3: Dashboard Development
- Create cloud-based web dashboard
- Implement real-time updates
- Add historical data visualization
- Mobile optimization

### Phase 4: Production Deployment
- Security hardening
- Performance optimization
- Monitoring and alerting
- Documentation and training

## Data Flow
1. **Edge**: MTConnect agents ‚Üí Local processor ‚Üí ADAM-6050 ‚Üí Data aggregation
2. **Transmission**: Edge ‚Üí HTTPS ‚Üí Cloud API
3. **Cloud**: API ‚Üí Database ‚Üí Dashboard
4. **Users**: Browser ‚Üí Cloud Dashboard

## Machine Idle Time Logic

### Overview
The system implements sophisticated logic to determine when machines are idle vs. actively working, with configurable thresholds and multiple detection criteria.

### Idle Detection Criteria

#### Criterion 1: No Counter Changes
- **Trigger**: Machine part counter hasn't changed for N minutes
- **Configurable**: Threshold set via dashboard settings (default: 5 minutes)
- **Action**: Machine marked as `IDLE`, idle time starts accumulating
- **Use Case**: Detects complete machine stops

#### Criterion 2: Anomalously Long Cycles
- **Trigger**: Current cycle time ‚â•20% longer than average cycle time
- **Fixed Threshold**: 20% deviation from average (non-configurable)
- **Action**: Machine marked as `IDLE`, idle time starts accumulating
- **Use Case**: Detects partial stops, jams, or abnormal operations

### Working State Detection

#### Normal Operation Requirements
- **Minimum Cycles**: At least 5 consecutive cycles
- **Uniformity**: All cycles within ¬±10% of average cycle time
- **Status**: Machine marked as `ACTIVE` with confidence "–ù–æ—Ä–º–∞–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞"

#### Setup/Adjustment Periods
- **Condition**: Cycles exist but are not uniform (¬±10% threshold)
- **Status**: Machine marked as `ACTIVE` with confidence "–ù–∞–ª–∞–¥–∫–∞/–Ω–µ—Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–∞—è —Ä–∞–±–æ—Ç–∞"
- **Idle Time**: Reset to 0 (not considered idle)

### Idle Time Restoration Logic

#### Emergency Situations Only
- **Trigger**: System restart detected via `process.uptime()` comparison
- **Action**: Restore accumulated idle time from `machine-states.cache.json`
- **Purpose**: Maintain idle time continuity during system crashes

#### Normal Stops
- **Behavior**: Idle time resets to 0 when machine resumes
- **Rationale**: Technical stops should not accumulate idle time

### Configuration

#### Dashboard Settings
- **Idle Time Threshold**: Configurable via dashboard (‚öôÔ∏è icon)
- **Storage**: Settings saved in browser `localStorage`
- **API**: Settings sent to `/api/settings` endpoint
- **Default**: 5 minutes

#### Fixed Parameters
- **Anomaly Threshold**: 20% (hardcoded)
- **Uniformity Threshold**: 10% (hardcoded)
- **Minimum Uniform Cycles**: 5 (hardcoded)

### Implementation Details

#### Core Component: `CycleTimeCalculator`
- **Location**: `src/cycle-time-calculator.ts`
- **Usage**: Centralized logic for both FANUC and ADAM machines
- **Methods**:
  - `getCycleTime()`: Main calculation method
  - `isAnomalouslyLongCycle()`: Anomaly detection
  - `isUniformCycles()`: Uniformity checking
  - `setSettings()`: Configuration updates

#### Data Flow
1. **Edge Processing**: `CycleTimeCalculator` processes machine data
2. **Status Determination**: Applies both idle criteria
3. **Cloud Storage**: Results stored in MongoDB
4. **Dashboard Display**: Real-time status updates

#### Logging
- **Debug Logs**: Detailed console output for troubleshooting
- **Status Tracking**: Machine state changes logged
- **Performance Metrics**: Cycle time calculations logged

### Benefits
- **Accurate Detection**: Distinguishes between normal stops and actual idle time
- **Configurable**: Adjustable thresholds for different production environments
- **Robust**: Handles system restarts and data loss scenarios
- **Real-time**: Immediate response to machine state changes

## Success Criteria
- ‚úÖ All 8 FANUC machines monitored in real-time
- ‚úÖ ADAM-6050 digital I/O integrated without .NET
- ‚úÖ Dashboard accessible from anywhere with internet
- ‚úÖ No inbound network connections to edge
- ‚úÖ Sub-second latency for real-time updates
- ‚úÖ 99.9% uptime for cloud services
- ‚úÖ Mobile-responsive interface

## Risk Mitigation
- **Network Security**: Only outbound HTTPS, no inbound ports
- **Data Loss**: Outbox pattern with local persistence
- **Cloud Downtime**: Local data buffering and retry logic
- **Performance**: Batch transmission and database optimization

## Technologies
- **Edge**: Node.js, TypeScript, jsmodbus, axios
- **Cloud**: NestJS, MongoDB, Railway.app, Docker
- **Frontend**: HTML5, CSS3, JavaScript, WebSocket
- **Security**: HTTPS, API keys, data encryption 