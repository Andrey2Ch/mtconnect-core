"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cycleTracker = exports.CycleTracker = void 0;
class CycleTracker {
    constructor() {
        this.machineStates = new Map(); // –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        this.currentCycles = new Map(); // —Ç–µ–∫—É—â–∏–µ —Ü–∏–∫–ª—ã
        this.completedCycles = []; // –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ —Ü–∏–∫–ª—ã
        this.productionStats = new Map();
    }
    updateMachineStatus(machineId, isRunning) {
        const previousState = this.machineStates.get(machineId);
        const now = new Date();
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –µ—Å–ª–∏ –Ω–µ—Ç
        if (!this.productionStats.has(machineId)) {
            this.productionStats.set(machineId, {
                machineId,
                totalCycles: 0,
                cyclesThisShift: 0,
                averageCycleTime: 0,
                isCurrentlyRunning: false,
                lastStatusChange: now,
                efficiency: 0
            });
        }
        const stats = this.productionStats.get(machineId);
        // –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è
        if (previousState !== undefined && previousState !== isRunning) {
            this.handleStateChange(machineId, previousState, isRunning, now);
        }
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        this.machineStates.set(machineId, isRunning);
        stats.isCurrentlyRunning = isRunning;
        stats.lastStatusChange = now;
        this.updateEfficiency(machineId);
    }
    handleStateChange(machineId, wasRunning, isRunning, timestamp) {
        const stats = this.productionStats.get(machineId);
        if (!wasRunning && isRunning) {
            // –°—Ç–∞–Ω–æ–∫ –ó–ê–ü–£–°–¢–ò–õ–°–Ø - –Ω–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—ã–π —Ü–∏–∫–ª
            this.startNewCycle(machineId, timestamp);
            console.log(`üöÄ –¶–ò–ö–õ –ù–ê–ß–ê–¢: ${machineId} –≤ ${timestamp.toLocaleTimeString()}`);
        }
        else if (wasRunning && !isRunning) {
            // –°—Ç–∞–Ω–æ–∫ –û–°–¢–ê–ù–û–í–ò–õ–°–Ø - –∑–∞–≤–µ—Ä—à–∞–µ–º —Ü–∏–∫–ª
            this.completeCycle(machineId, timestamp);
            const lastCycle = this.getLastCompletedCycle(machineId);
            if (lastCycle) {
                console.log(`‚úÖ –¶–ò–ö–õ –ó–ê–í–ï–†–®–ï–ù: ${machineId} –∑–∞ ${lastCycle.duration}—Å–µ–∫ (—Ü–∏–∫–ª #${lastCycle.cycleNumber})`);
            }
        }
    }
    startNewCycle(machineId, startTime) {
        const stats = this.productionStats.get(machineId);
        const newCycle = {
            machineId,
            cycleNumber: stats.totalCycles + 1,
            startTime,
            status: 'RUNNING'
        };
        this.currentCycles.set(machineId, newCycle);
        stats.currentCycleStartTime = startTime;
    }
    completeCycle(machineId, endTime) {
        const currentCycle = this.currentCycles.get(machineId);
        if (!currentCycle)
            return;
        const stats = this.productionStats.get(machineId);
        const duration = Math.round((endTime.getTime() - currentCycle.startTime.getTime()) / 1000);
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–∏–∫–ª
        currentCycle.endTime = endTime;
        currentCycle.duration = duration;
        currentCycle.status = 'COMPLETED';
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–π —Ü–∏–∫–ª
        this.completedCycles.push({ ...currentCycle });
        this.currentCycles.delete(machineId);
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        stats.totalCycles++;
        stats.cyclesThisShift++;
        stats.lastCycleTime = duration;
        stats.currentCycleStartTime = undefined;
        // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è —Ü–∏–∫–ª–∞
        this.updateAverageCycleTime(machineId);
    }
    updateAverageCycleTime(machineId) {
        const stats = this.productionStats.get(machineId);
        const machineCycles = this.completedCycles.filter(c => c.machineId === machineId && c.duration);
        if (machineCycles.length > 0) {
            const totalTime = machineCycles.reduce((sum, cycle) => sum + (cycle.duration || 0), 0);
            stats.averageCycleTime = Math.round(totalTime / machineCycles.length);
        }
    }
    updateEfficiency(machineId) {
        const stats = this.productionStats.get(machineId);
        // –ü—Ä–æ—Å—Ç–æ–π —Ä–∞—Å—á–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π —á–∞—Å
        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
        const recentCycles = this.completedCycles.filter(c => c.machineId === machineId &&
            c.startTime > oneHourAgo &&
            c.duration);
        if (recentCycles.length > 0) {
            const totalProductionTime = recentCycles.reduce((sum, cycle) => sum + (cycle.duration || 0), 0);
            const totalTime = 60 * 60; // 1 —á–∞—Å –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
            stats.efficiency = Math.round((totalProductionTime / totalTime) * 100);
        }
    }
    // –ü—É–±–ª–∏—á–Ω—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
    getMachineStats(machineId) {
        return this.productionStats.get(machineId);
    }
    getAllStats() {
        return Array.from(this.productionStats.values());
    }
    getLastCompletedCycle(machineId) {
        return this.completedCycles
            .filter(c => c.machineId === machineId)
            .sort((a, b) => b.cycleNumber - a.cycleNumber)[0];
    }
    getCurrentCycle(machineId) {
        return this.currentCycles.get(machineId);
    }
    getTodaysCycles(machineId) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        return this.completedCycles.filter(c => c.machineId === machineId &&
            c.startTime >= today);
    }
    getProductionSummary() {
        const stats = this.getAllStats();
        const totalCycles = stats.reduce((sum, s) => sum + s.totalCycles, 0);
        const averageEfficiency = stats.length > 0
            ? Math.round(stats.reduce((sum, s) => sum + s.efficiency, 0) / stats.length)
            : 0;
        return {
            totalMachines: stats.length,
            totalCycles: totalCycles,
            machinesRunning: stats.filter(s => s.isCurrentlyRunning).length,
            averageEfficiency,
            machines: stats.map(s => ({
                id: s.machineId,
                cycles: s.totalCycles,
                running: s.isCurrentlyRunning,
                efficiency: s.efficiency,
                avgCycleTime: s.averageCycleTime
            }))
        };
    }
    // –ú–µ—Ç–æ–¥ –¥–ª—è —Å–±—Ä–æ—Å–∞ —Å—á–µ—Ç—á–∏–∫–æ–≤ —Å–º–µ–Ω—ã
    resetShiftCounters() {
        for (const stats of this.productionStats.values()) {
            stats.cyclesThisShift = 0;
        }
        console.log('üîÑ –°—á–µ—Ç—á–∏–∫–∏ —Å–º–µ–Ω—ã —Å–±—Ä–æ—à–µ–Ω—ã');
    }
}
exports.CycleTracker = CycleTracker;
exports.cycleTracker = new CycleTracker();
exports.default = exports.cycleTracker;
