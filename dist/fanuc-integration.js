"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FanucIntegration = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const focas_real_1 = require("./focas-real");
const cycle_tracker_1 = __importDefault(require("./cycle-tracker"));
// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã FOCAS (–∏–∑ Fwlib32.h)
const EW_OK = 0;
const EW_SOCKET = -8;
const EW_TIMEOUT = -16;
class FanucIntegration {
    constructor() {
        this.isAvailable = false;
        this.machines = new Map();
        this.machineIPs = new Map();
        this.focasWarningShown = false; // –§–ª–∞–≥ –¥–ª—è –æ–¥–Ω–æ–∫—Ä–∞—Ç–Ω–æ–≥–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
        this.dllPath = path.join(process.cwd(), 'Fwlib32.dll');
        this.checkAvailability();
    }
    checkAvailability() {
        try {
            this.isAvailable = fs.existsSync(this.dllPath);
            if (this.isAvailable) {
                console.log(`‚úÖ FANUC –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≥–æ—Ç–æ–≤–∞. DLL –Ω–∞–π–¥–µ–Ω–∞: ${this.dllPath}`);
            }
            else {
                console.log(`‚ùå FANUC DLL –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: ${this.dllPath}`);
                console.log(`‚ö†Ô∏è –°–∏—Å—Ç–µ–º–∞ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Ç–æ–ª—å–∫–æ —Å TCP –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è–º–∏ –±–µ–∑ —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö FOCAS`);
                this.focasWarningShown = true;
            }
        }
        catch (error) {
            console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ FANUC DLL:', error);
            this.isAvailable = false;
        }
    }
    isReady() {
        return this.isAvailable;
    }
    // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å—Ç–∞–Ω–∫—É FANUC
    async connectToMachine(machineId, ip, port = 8193) {
        console.log(`üîß –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ FANUC ${machineId} –Ω–∞ ${ip}:${port}`);
        try {
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º IP –¥–ª—è —ç—Ç–æ–π –º–∞—à–∏–Ω—ã
            this.machineIPs.set(machineId, ip);
            // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è —á–µ—Ä–µ–∑ –†–ï–ê–õ–¨–ù–´–ô FOCAS
            if (focas_real_1.realFocasClient.isAvailable()) {
                const result = await focas_real_1.realFocasClient.connect(ip, port);
                if (result.success) {
                    const machineData = {
                        timestamp: new Date().toISOString(),
                        handle: result.handle,
                        connected: true,
                        status: { mode: 0, running: 0, motion: 0, emergency: 0, alarm: 0, edit: 0 },
                        positions: {
                            X: { value: 0, unit: 'mm' },
                            Y: { value: 0, unit: 'mm' },
                            Z: { value: 0, unit: 'mm' }
                        },
                        spindle: { speed: 0, override: 100 },
                        feed: { rate: 0, override: 100 },
                        program: { number: 0, sequence: 0, block: '' },
                        alarms: []
                    };
                    this.machines.set(machineId, machineData);
                    console.log(`‚úÖ ${machineId} (${ip}) –ø–æ–¥–∫–ª—é—á–µ–Ω —á–µ—Ä–µ–∑ –†–ï–ê–õ–¨–ù–´–ô FOCAS`);
                    return true;
                }
            }
            // FALLBACK: –¢–µ—Å—Ç TCP –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
            const isReachable = await this.testConnection(ip, port);
            if (isReachable) {
                const handle = Math.floor(Math.random() * 1000) + 1;
                const machineData = {
                    timestamp: new Date().toISOString(),
                    handle: handle,
                    connected: true,
                    status: {
                        mode: 0,
                        running: 0,
                        motion: 0,
                        emergency: 0,
                        alarm: 0,
                        edit: 0
                    },
                    positions: {
                        X: { value: 0, unit: 'mm' },
                        Y: { value: 0, unit: 'mm' },
                        Z: { value: 0, unit: 'mm' }
                    },
                    spindle: {
                        speed: 0,
                        override: 100
                    },
                    feed: {
                        rate: 0,
                        override: 100
                    },
                    program: {
                        number: 0,
                        sequence: 0,
                        block: ''
                    },
                    alarms: []
                };
                this.machines.set(machineId, machineData);
                console.log(`‚úÖ FANUC ${machineId} –ø–æ–¥–∫–ª—é—á–µ–Ω (handle: ${handle})`);
                return true;
            }
            else {
                console.log(`‚ùå FANUC ${machineId} –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ –∞–¥—Ä–µ—Å—É ${ip}:${port}`);
                return false;
            }
        }
        catch (error) {
            console.error(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ FANUC ${machineId}:`, error);
            return false;
        }
    }
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –ø–æ —Å–µ—Ç–∏
    async testConnection(ip, port) {
        return new Promise((resolve) => {
            const net = require('net');
            const socket = new net.Socket();
            const timeout = setTimeout(() => {
                socket.destroy();
                resolve(false);
            }, 5000);
            socket.on('connect', () => {
                clearTimeout(timeout);
                socket.end();
                resolve(true);
            });
            socket.on('error', () => {
                clearTimeout(timeout);
                resolve(false);
            });
            try {
                socket.connect(port, ip);
            }
            catch {
                clearTimeout(timeout);
                resolve(false);
            }
        });
    }
    // –ü–æ–ª—É—á–µ–Ω–∏–µ IP –∞–¥—Ä–µ—Å–∞ –º–∞—à–∏–Ω—ã
    getIpForMachine(machineId) {
        return this.machineIPs.get(machineId);
    }
    // –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å —Å—Ç–∞–Ω–∫–∞ (–Ω–∞—Å—Ç–æ—è—â–∏–µ FOCAS –≤—ã–∑–æ–≤—ã)
    async getMachineData(machineId) {
        const machine = this.machines.get(machineId);
        if (!machine || !machine.connected) {
            return null;
        }
        try {
            const ip = this.getIpForMachine(machineId);
            if (!ip) {
                console.error(`‚ùå IP –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è –º–∞—à–∏–Ω—ã ${machineId}`);
                machine.status.running = 0;
                machine.status.motion = 0;
                machine.status.mode = 0;
                return machine;
            }
            let focasData = null;
            let focasAvailableAndSuccessful = false;
            if (focas_real_1.realFocasClient.isAvailable()) {
                try {
                    focasData = await focas_real_1.realFocasClient.getMachineData(machineId, ip);
                    if (focasData) {
                        focasAvailableAndSuccessful = true;
                    }
                }
                catch (error) {
                    console.log(`‚ö†Ô∏è  FOCAS –æ—à–∏–±–∫–∞ –¥–ª—è ${ip}: ${error.message || error}`);
                }
            }
            machine.timestamp = new Date().toISOString();
            if (focasAvailableAndSuccessful && focasData && focasData.status) {
                machine.positions.X.value = focasData.status.position?.x || 0;
                machine.positions.Y.value = focasData.status.position?.y || 0;
                machine.positions.Z.value = focasData.status.position?.z || 0;
                machine.spindle.speed = focasData.status.spindleSpeed || 0;
                machine.feed.rate = focasData.status.feedrate || 0;
                machine.program.number = focasData.status.programNumber || 0;
                machine.status.alarm = (focasData.status.alarms && focasData.status.alarms.length > 0) ? 1 : 0;
                machine.status.emergency = (focasData.status.alarms && focasData.status.alarms.some((a) => a.includes('EMERGENCY'))) ? 1 : 0;
                machine.alarms = focasData.status.alarms || [];
                // –í—ã–≤–æ–¥–∏–º –≤ –ª–æ–≥ —Å—Ç—Ä—É–∫—Ç—É—Ä—É focasData.status, —á—Ç–æ–±—ã –ø–æ–Ω—è—Ç—å, –∫–∞–∫ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å running
                console.log(`üîç FOCAS –¥–∞–Ω–Ω—ã–µ (—Å—Ç–∞—Ç—É—Å) –¥–ª—è ${ip}:`, JSON.stringify(focasData.status));
                // –í–†–ï–ú–ï–ù–ù–û: –ø–æ–∫–∞ –Ω–µ –∑–Ω–∞–µ–º —Ç–æ—á–Ω–æ–µ –ø–æ–ª–µ, —Å—Ç–∞–≤–∏–º running = 0
                // –ü–æ–∑–∂–µ, –Ω–∞ –æ—Å–Ω–æ–≤–µ –ª–æ–≥–∞ –≤—ã—à–µ, –º—ã –Ω–∞–ø–∏—à–µ–º –∑–¥–µ—Å—å –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –ª–æ–≥–∏–∫—É.
                machine.status.running = 0;
            }
            else {
                machine.status.running = 0;
                if (!focasAvailableAndSuccessful) {
                    console.log(`‚ÑπÔ∏è FOCAS –¥–∞–Ω–Ω—ã–µ –¥–ª—è ${ip} –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã, —Å—Ç–∞—Ç—É—Å running = 0.`);
                }
            }
            machine.status.motion = machine.status.running === 1 && machine.feed.rate > 0 ? 1 : 0;
            machine.status.mode = machine.status.running === 1 ? 1 : 0;
            cycle_tracker_1.default.updateMachineStatus(machineId, machine.status.running === 1);
            return machine;
        }
        catch (error) {
            console.error(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è ${machineId}: ${error.message || error}`);
            const machine = this.machines.get(machineId);
            if (machine) {
                machine.status.running = 0;
                machine.status.motion = 0;
                machine.status.mode = 0;
                return machine;
            }
            return null;
        }
    }
    // –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç —Å—Ç–∞–Ω–∫–∞
    async disconnectFromMachine(machineId) {
        const machine = this.machines.get(machineId);
        if (!machine) {
            return false;
        }
        try {
            // –ó–¥–µ—Å—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤—ã–∑–æ–≤ cnc_freelibhndl()
            machine.connected = false;
            this.machines.delete(machineId);
            console.log(`‚úÖ FANUC ${machineId} –æ—Ç–∫–ª—é—á–µ–Ω (handle: ${machine.handle})`);
            return true;
        }
        catch (error) {
            console.error(`‚ùå –û—à–∏–±–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è FANUC ${machineId}:`, error);
            return false;
        }
    }
    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã—Ö –º–∞—à–∏–Ω
    getConnectedMachines() {
        return Array.from(this.machines.keys()).filter(id => {
            const machine = this.machines.get(id);
            return machine && machine.connected;
        });
    }
    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    getStatistics() {
        const connectedCount = this.getConnectedMachines().length;
        const runningCount = Array.from(this.machines.values())
            .filter(m => m.connected && m.status.running === 1).length;
        return {
            connected: connectedCount,
            running: runningCount,
            efficiency: connectedCount > 0 ? Math.round((runningCount / connectedCount) * 100) : 0
        };
    }
    // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ MTConnect —Ñ–æ—Ä–º–∞—Ç
    toMTConnectData(machineId) {
        const machine = this.machines.get(machineId);
        if (!machine) {
            return null;
        }
        return {
            timestamp: machine.timestamp,
            programNumber: machine.program.number,
            currentProgram: machine.program.number,
            sequenceNumber: machine.program.sequence,
            feedrate: machine.feed.rate,
            spindleSpeed: machine.spindle.speed,
            positions: machine.positions,
            status: {
                mode: machine.status.mode,
                automatic: machine.status.mode,
                running: machine.status.running,
                motion: machine.status.motion,
                emergency: machine.status.emergency,
                alarm: machine.status.alarm
            }
        };
    }
}
exports.FanucIntegration = FanucIntegration;
exports.default = FanucIntegration;
