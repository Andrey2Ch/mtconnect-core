import * as net from 'net';
import { EventEmitter } from 'events';

export interface SHDRDataItem {
    timestamp: string;
    device: string;
    dataItem: string;
    value: string;
}

export interface SHDRConnectionConfig {
    ip: string;
    port: number;
    machineId: string;
    machineName: string;
    reconnectInterval?: number;
    timeout?: number;
}

export class SHDRClient extends EventEmitter {
    private socket: net.Socket | null = null;
    private config: SHDRConnectionConfig;
    private reconnectTimer: NodeJS.Timeout | null = null;
    private isConnected: boolean = false;
    private reconnectAttempts: number = 0;
    private maxReconnectAttempts: number = 5;
    private buffer: string = '';

    constructor(config: SHDRConnectionConfig) {
        super();
        this.config = {
            reconnectInterval: 5000,
            timeout: 10000,
            ...config
        };
    }

    public connect(): void {
        if (this.socket && !this.socket.destroyed) {
            this.socket.destroy();
        }

        this.socket = new net.Socket();
        this.socket.setTimeout(this.config.timeout!);

        this.socket.on('connect', () => {
            console.log(`‚úÖ SHDR –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ ${this.config.machineName} (${this.config.ip}:${this.config.port})`);
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.emit('connect');
        });

        this.socket.on('data', (chunk) => {
            this.handleData(chunk);
        });

        this.socket.on('timeout', () => {
            console.log(`‚è∞ SHDR timeout –¥–ª—è ${this.config.machineName}`);
            this.handleDisconnect();
        });

        this.socket.on('error', (error) => {
            console.log(`‚ùå SHDR –æ—à–∏–±–∫–∞ –¥–ª—è ${this.config.machineName}: ${error.message}`);
            this.emit('error', error);
            this.handleDisconnect();
        });

        this.socket.on('close', () => {
            console.log(`üîå SHDR —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ –¥–ª—è ${this.config.machineName}`);
            this.handleDisconnect();
        });

        console.log(`üîÑ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ SHDR –∫ ${this.config.machineName} (${this.config.ip}:${this.config.port})...`);
        this.socket.connect(this.config.port, this.config.ip);
    }

    private handleData(chunk: Buffer): void {
        // –î–æ–±–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –∫ –±—É—Ñ–µ—Ä—É
        this.buffer += chunk.toString();
        
        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ–ª–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
        const lines = this.buffer.split('\n');
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–µ–ø–æ–ª–Ω—É—é –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–æ–∫—É –≤ –±—É—Ñ–µ—Ä–µ
        this.buffer = lines.pop() || '';
        
        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ–ª–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
        lines.forEach(line => {
            if (line.trim()) {
                this.parseSHDRLine(line.trim());
            }
        });
    }

    private parseSHDRLine(line: string): void {
        const parts = line.split('|');
        
        if (parts.length >= 4) {
            const dataItem: SHDRDataItem = {
                timestamp: parts[0],
                device: parts[1],
                dataItem: parts[2],
                value: parts[3]
            };
            
            this.emit('data', dataItem);
        } else {
            console.warn(`‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç SHDR –¥–ª—è ${this.config.machineName}: ${line}`);
        }
    }

    private handleDisconnect(): void {
        this.isConnected = false;
        
        if (this.socket) {
            this.socket.destroy();
            this.socket = null;
        }

        this.emit('disconnect');
        
        // –ê–≤—Ç–æ–ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            console.log(`üîÑ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ SHDR –∫ ${this.config.machineName} —á–µ—Ä–µ–∑ ${this.config.reconnectInterval}–º—Å (–ø–æ–ø—ã—Ç–∫–∞ ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
            
            this.reconnectTimer = setTimeout(() => {
                this.connect();
            }, this.config.reconnectInterval);
        } else {
            console.log(`‚ùå –ú–∞–∫—Å–∏–º—É–º –ø–æ–ø—ã—Ç–æ–∫ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∏—Å—á–µ—Ä–ø–∞–Ω –¥–ª—è ${this.config.machineName}`);
            this.emit('maxReconnectAttemptsReached');
        }
    }

    public disconnect(): void {
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
        }

        if (this.socket) {
            this.socket.destroy();
            this.socket = null;
        }

        this.isConnected = false;
        this.reconnectAttempts = 0;
    }

    public getConnectionStatus(): boolean {
        return this.isConnected;
    }

    public getReconnectAttempts(): number {
        return this.reconnectAttempts;
    }
}

export class SHDRManager extends EventEmitter {
    private clients: Map<string, SHDRClient> = new Map();
    private dataStore: Map<string, Map<string, SHDRDataItem>> = new Map();

    public addMachine(config: SHDRConnectionConfig): void {
        const client = new SHDRClient(config);
        
        client.on('connect', () => {
            console.log(`üîó SHDR Manager: ${config.machineName} –ø–æ–¥–∫–ª—é—á–µ–Ω`);
            this.emit('machineConnected', config.machineId);
        });

        client.on('disconnect', () => {
            console.log(`üîå SHDR Manager: ${config.machineName} –æ—Ç–∫–ª—é—á–µ–Ω`);
            this.emit('machineDisconnected', config.machineId);
        });

        client.on('data', (dataItem: SHDRDataItem) => {
            this.updateDataStore(config.machineId, dataItem);
            this.emit('dataReceived', config.machineId, dataItem);
        });

        client.on('error', (error) => {
            this.emit('machineError', config.machineId, error);
        });

        this.clients.set(config.machineId, client);
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –º–∞—à–∏–Ω—ã
        if (!this.dataStore.has(config.machineId)) {
            this.dataStore.set(config.machineId, new Map());
        }
        
        client.connect();
    }

    private updateDataStore(machineId: string, dataItem: SHDRDataItem): void {
        const machineData = this.dataStore.get(machineId);
        if (machineData) {
            machineData.set(dataItem.dataItem, dataItem);
        }
    }

    public getMachineData(machineId: string): Map<string, SHDRDataItem> | undefined {
        return this.dataStore.get(machineId);
    }

    public getAllMachinesData(): Map<string, Map<string, SHDRDataItem>> {
        return this.dataStore;
    }

    public getMachineConnectionStatus(machineId: string): boolean {
        const client = this.clients.get(machineId);
        return client ? client.getConnectionStatus() : false;
    }

    public getAllConnectionStatuses(): Map<string, boolean> {
        const statuses = new Map<string, boolean>();
        for (const [machineId, client] of this.clients) {
            statuses.set(machineId, client.getConnectionStatus());
        }
        return statuses;
    }

    public disconnectAll(): void {
        for (const client of this.clients.values()) {
            client.disconnect();
        }
        this.clients.clear();
        this.dataStore.clear();
    }

    public getConnectedMachinesCount(): number {
        let count = 0;
        for (const client of this.clients.values()) {
            if (client.getConnectionStatus()) {
                count++;
            }
        }
        return count;
    }

    // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è SHDR –¥–∞–Ω–Ω—ã—Ö –≤ MTConnect —Ñ–æ—Ä–º–∞—Ç
    public convertToMTConnectFormat(machineId: string): any {
        const machineData = this.dataStore.get(machineId);
        if (!machineData) {
            return null;
        }

        const timestamp = new Date().toISOString();
        const deviceStream = {
            $: {
                name: machineId,
                uuid: machineId.toLowerCase()
            },
            ComponentStream: [
                {
                    $: {
                        component: "Controller",
                        componentId: "controller"
                    },
                    Events: {} as { [key: string]: any },
                    Samples: {} as { [key: string]: any }
                },
                {
                    $: {
                        component: "Path", 
                        componentId: "path",
                        name: "path"
                    },
                    Events: {} as { [key: string]: any },
                    Samples: {} as { [key: string]: any }
                }
            ]
        };

        // –ú–∞–ø–ø–∏–Ω–≥ SHDR –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤ MTConnect —Å—Ç—Ä—É–∫—Ç—É—Ä—É
        for (const [dataItemName, dataItem] of machineData) {
            const mtconnectItem = {
                _: dataItem.value,
                $: {
                    dataItemId: dataItemName,
                    timestamp: dataItem.timestamp || timestamp,
                    name: dataItemName
                }
            };

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫—É–¥–∞ –ø–æ–º–µ—Å—Ç–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç (Events –∏–ª–∏ Samples)
            const isEvent = ['avail', 'mode', 'exec', 'program', 'block', 'estop', 'door', 'coolant'].includes(dataItemName);
            const componentIndex = ['Xact', 'Yact', 'Zact', 'program', 'block', 'exec'].includes(dataItemName) ? 1 : 0;
            
            if (isEvent) {
                deviceStream.ComponentStream[componentIndex].Events[this.capitalizeFirst(dataItemName)] = mtconnectItem;
            } else {
                deviceStream.ComponentStream[componentIndex].Samples[this.capitalizeFirst(dataItemName)] = mtconnectItem;
            }
        }

        return deviceStream;
    }

    private capitalizeFirst(str: string): string {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
} 